/**
 * Patterndex Data - All 24 Design Pattern Creatures
 * Sets window.PATTERNDEX_DATA for use across all pages.
 */
window.PATTERNDEX_DATA = {
  types: {
    electric:  { name: 'Electric',  color: '#f8d030', concept: 'Transformation & Conversion' },
    fairy:     { name: 'Fairy',     color: '#ee99ac', concept: 'Simplification & Elegance' },
    psychic:   { name: 'Psychic',   color: '#f85888', concept: 'Abstraction & Indirection' },
    steel:     { name: 'Steel',     color: '#b8b8d0', concept: 'Structure & Encapsulation' },
    grass:     { name: 'Grass',     color: '#78c850', concept: 'Composition & Growth' },
    dragon:    { name: 'Dragon',    color: '#7038f8', concept: 'Power & Complexity' },
    ghost:     { name: 'Ghost',     color: '#705898', concept: 'Indirection & Proxying' },
    fire:      { name: 'Fire',      color: '#f08030', concept: 'Dynamic Behavior & Mutation' },
    normal:    { name: 'Normal',    color: '#a8a878', concept: 'Interfaces & Contracts' },
    bug:       { name: 'Bug',       color: '#a8b820', concept: 'Lightweight & Efficiency' },
    dark:      { name: 'Dark',      color: '#705848', concept: 'Encapsulation & Hiding' },
    water:     { name: 'Water',     color: '#6890f0', concept: 'Flow & Sequencing' },
    fighting:  { name: 'Fighting',  color: '#c03028', concept: 'Direct Action & Commands' },
    flying:    { name: 'Flying',    color: '#a890f0', concept: 'Traversal & Iteration' },
    poison:    { name: 'Poison',    color: '#a040a0', concept: 'State Mutation & Side Effects' },
    ice:       { name: 'Ice',       color: '#98d8d8', concept: 'Immutability & Snapshots' }
  },

  // Type effectiveness: attacker -> defender -> multiplier
  // 2 = super effective, 0.5 = not very effective, 0 = immune
  // Only non-1x entries listed
  typeChart: {
    fire:     { steel: 2, grass: 2, ice: 2, bug: 2, water: 0.5, fire: 0.5, dragon: 0.5 },
    water:    { fire: 2, poison: 2, flying: 0.5, water: 0.5, grass: 0.5, dragon: 0.5 },
    grass:    { water: 2, normal: 2, steel: 0.5, fire: 0.5, grass: 0.5, dragon: 0.5, bug: 0.5, flying: 0.5, poison: 0.5 },
    electric: { water: 2, flying: 2, steel: 0.5, electric: 0.5, grass: 0.5, dragon: 0.5 },
    ice:      { grass: 2, flying: 2, dragon: 2, poison: 2, fire: 0.5, water: 0.5, ice: 0.5, steel: 0.5 },
    fighting: { normal: 2, dark: 2, steel: 2, ice: 2, ghost: 0, psychic: 0.5, fairy: 0.5, bug: 0.5, flying: 0.5, poison: 0.5 },
    psychic:  { fighting: 2, poison: 2, dark: 0, psychic: 0.5, steel: 0.5 },
    dark:     { psychic: 2, ghost: 2, dark: 0.5, fairy: 0.5, fighting: 0.5 },
    fairy:    { dragon: 2, fighting: 2, dark: 2, fire: 0.5, steel: 0.5, poison: 0.5 },
    dragon:   { dragon: 2, fairy: 0, steel: 0.5 },
    ghost:    { ghost: 2, psychic: 2, normal: 0, dark: 0.5 },
    steel:    { ice: 2, fairy: 2, fire: 0.5, water: 0.5, steel: 0.5, electric: 0.5 },
    bug:      { grass: 2, psychic: 2, dark: 2, ghost: 0.5, fire: 0.5, steel: 0.5, fairy: 0.5, fighting: 0.5, flying: 0.5, poison: 0.5 },
    flying:   { grass: 2, fighting: 2, bug: 2, electric: 0.5, steel: 0.5 },
    poison:   { grass: 2, fairy: 2, ghost: 0.5, poison: 0.5, steel: 0, dark: 0.5 },
    normal:   { ghost: 0, steel: 0.5 }
  },

  creatures: [
    // ===== CREATIONAL (001-005) =====
    {
      id: '001',
      name: 'Factorex',
      pattern: 'Abstract Factory',
      category: 'creational',
      types: ['steel', 'dragon'],
      stats: { complexity: 8, flexibility: 9, decoupling: 9, abstraction: 10, performance: 5, popularity: 7 },
      visual: { body: 'angular', features: ['horns', 'aura'], accent: 'wings' },
      intent: 'Provide an interface for creating families of related objects without specifying their concrete classes.',
      problem: 'You need to create objects that belong together as a family, but you don\'t want to hard-code which specific family gets created.',
      solution: 'Define abstract interfaces for each product and for the factory itself. Concrete factories implement these interfaces to produce products from the same family.',
      analogy: 'A furniture store that offers matching sets (Victorian, Modern, Art Deco). You pick a style, and the store gives you a matching chair, table, and sofa without you specifying each piece.',
      codeHint: 'interface GUIFactory {\n  createButton(): Button;\n  createCheckbox(): Checkbox;\n}\n\nclass WinFactory implements GUIFactory { ... }\nclass MacFactory implements GUIFactory { ... }',
      participants: ['AbstractFactory', 'ConcreteFactory', 'AbstractProduct', 'ConcreteProduct', 'Client'],
      related: ['003', '002', '004', '005']
    },
    {
      id: '002',
      name: 'Buildrix',
      pattern: 'Builder',
      category: 'creational',
      types: ['steel', 'grass'],
      stats: { complexity: 6, flexibility: 8, decoupling: 7, abstraction: 7, performance: 7, popularity: 9 },
      visual: { body: 'tall', features: ['shield', 'markings'], accent: 'tail' },
      intent: 'Separate the construction of a complex object from its representation so that the same construction process can create different representations.',
      problem: 'Creating complex objects requires many steps, and the construction process should be independent of the parts that make up the object.',
      solution: 'Extract the object construction into a separate Builder class. A Director coordinates the building steps, while different builders can produce different products using the same process.',
      analogy: 'Building a house: the architect (Director) gives the same blueprint to different construction crews (Builders). One builds a wooden cabin, another a stone castle, but both follow the same plan.',
      codeHint: 'class QueryBuilder {\n  private query = {};\n  select(fields) { ... return this; }\n  where(condition) { ... return this; }\n  orderBy(field) { ... return this; }\n  build() { return this.query; }\n}',
      participants: ['Builder', 'ConcreteBuilder', 'Director', 'Product'],
      related: ['001', '008']
    },
    {
      id: '003',
      name: 'Forgeling',
      pattern: 'Factory Method',
      category: 'creational',
      types: ['steel', 'fire'],
      stats: { complexity: 4, flexibility: 7, decoupling: 7, abstraction: 6, performance: 8, popularity: 10 },
      visual: { body: 'round', features: ['horns', 'claws'], accent: 'aura' },
      intent: 'Define an interface for creating an object, but let subclasses decide which class to instantiate.',
      problem: 'A class can\'t anticipate which class of objects it needs to create, or wants its subclasses to specify the objects it creates.',
      solution: 'Define a method in the base class that returns a product object. Subclasses override this method to change the type of product being created.',
      analogy: 'A logistics company. The base company knows it needs to deliver things, but whether it uses trucks or ships depends on the subclass (road logistics vs. sea logistics).',
      codeHint: 'abstract class Dialog {\n  abstract createButton(): Button;\n\n  render() {\n    const btn = this.createButton();\n    btn.onClick(closeDialog);\n    btn.render();\n  }\n}',
      participants: ['Creator', 'ConcreteCreator', 'Product', 'ConcreteProduct'],
      related: ['001', '022']
    },
    {
      id: '004',
      name: 'Clonyx',
      pattern: 'Prototype',
      category: 'creational',
      types: ['ice', 'normal'],
      stats: { complexity: 3, flexibility: 6, decoupling: 5, abstraction: 4, performance: 9, popularity: 6 },
      visual: { body: 'multi', features: ['markings'], accent: 'aura' },
      intent: 'Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.',
      problem: 'Creating an object is expensive or complex, and you need many similar objects. Or you want to avoid the coupling to specific classes that "new" introduces.',
      solution: 'Give each object a clone() method that creates a copy. The client can produce new objects by cloning an existing prototype instead of calling constructors.',
      analogy: 'Cell division in biology. Instead of building a new cell from scratch, an existing cell copies itself, then the copy can be modified as needed.',
      codeHint: 'interface Prototype {\n  clone(): Prototype;\n}\n\nclass Shape implements Prototype {\n  clone() {\n    return Object.assign(\n      Object.create(this), this\n    );\n  }\n}',
      participants: ['Prototype', 'ConcretePrototype', 'Client'],
      related: ['001', '018']
    },
    {
      id: '005',
      name: 'Unixen',
      pattern: 'Singleton',
      category: 'creational',
      types: ['dark', 'psychic'],
      stats: { complexity: 2, flexibility: 2, decoupling: 2, abstraction: 3, performance: 8, popularity: 10 },
      visual: { body: 'round', features: ['aura'], accent: 'markings' },
      intent: 'Ensure a class has only one instance, and provide a global point of access to it.',
      problem: 'Some resources (database connections, config managers, loggers) should exist as a single shared instance. Multiple instances would cause conflicts or waste resources.',
      solution: 'Make the constructor private and provide a static method that returns the same instance every time it is called.',
      analogy: 'A country has one government. No matter who asks "who\'s in charge?", they get the same answer. You can\'t create a second government (legally).',
      codeHint: 'class Database {\n  private static instance: Database;\n  private constructor() {}\n\n  static getInstance(): Database {\n    if (!Database.instance) {\n      Database.instance = new Database();\n    }\n    return Database.instance;\n  }\n}',
      participants: ['Singleton'],
      related: ['001', '003']
    },

    // ===== STRUCTURAL (006-012) =====
    {
      id: '006',
      name: 'Adaptle',
      pattern: 'Adapter',
      category: 'structural',
      types: ['electric', 'fairy'],
      stats: { complexity: 3, flexibility: 7, decoupling: 8, abstraction: 5, performance: 8, popularity: 9 },
      visual: { body: 'round', features: ['antennae', 'tail'], accent: 'markings' },
      intent: 'Convert the interface of a class into another interface clients expect. Lets classes work together that couldn\'t otherwise because of incompatible interfaces.',
      problem: 'You have an existing class whose interface doesn\'t match what a client expects, and you can\'t modify either the client or the existing class.',
      solution: 'Create a wrapper class (adapter) that translates calls from the client\'s expected interface into the format the existing class understands.',
      analogy: 'A power adapter when traveling abroad. Your laptop plug doesn\'t fit the foreign socket, so you use an adapter that accepts your plug and connects to their outlet.',
      codeHint: 'class XMLToJSONAdapter {\n  constructor(private xmlParser: XMLParser) {}\n\n  parseJSON(data: string): object {\n    const xml = this.xmlParser.parseXML(data);\n    return this.convertToJSON(xml);\n  }\n}',
      participants: ['Target', 'Adapter', 'Adaptee', 'Client'],
      related: ['007', '009', '010']
    },
    {
      id: '007',
      name: 'Bridgitar',
      pattern: 'Bridge',
      category: 'structural',
      types: ['psychic', 'steel'],
      stats: { complexity: 7, flexibility: 9, decoupling: 10, abstraction: 9, performance: 7, popularity: 5 },
      visual: { body: 'tall', features: ['wings', 'aura'], accent: 'horns' },
      intent: 'Decouple an abstraction from its implementation so that the two can vary independently.',
      problem: 'You have a class that has two dimensions of variation (e.g., shape and color, or platform and feature). Using inheritance for both leads to a class explosion.',
      solution: 'Split the class into two separate hierarchies: abstraction and implementation. The abstraction holds a reference to the implementation and delegates work to it.',
      analogy: 'A TV remote (abstraction) and the TV (implementation). You can change the remote without changing the TV, and vice versa. Any remote can work with any TV through the same interface.',
      codeHint: 'class RemoteControl {\n  constructor(protected device: Device) {}\n  togglePower() {\n    if (this.device.isEnabled())\n      this.device.disable();\n    else\n      this.device.enable();\n  }\n}',
      participants: ['Abstraction', 'RefinedAbstraction', 'Implementor', 'ConcreteImplementor'],
      related: ['006', '021']
    },
    {
      id: '008',
      name: 'Composix',
      pattern: 'Composite',
      category: 'structural',
      types: ['grass', 'dragon'],
      stats: { complexity: 5, flexibility: 8, decoupling: 6, abstraction: 7, performance: 6, popularity: 8 },
      visual: { body: 'multi', features: ['horns', 'tail'], accent: 'markings' },
      intent: 'Compose objects into tree structures to represent part-whole hierarchies. Let clients treat individual objects and compositions uniformly.',
      problem: 'You need to work with tree-structured data where clients should treat both leaves and containers the same way.',
      solution: 'Define a Component interface shared by both simple leaves and composite containers. Composites hold children and delegate operations to them.',
      analogy: 'A file system. Files and folders share common operations (move, copy, delete). A folder contains files and other folders, but you interact with both the same way.',
      codeHint: 'interface Component {\n  execute(): void;\n}\n\nclass Composite implements Component {\n  private children: Component[] = [];\n  add(child: Component) { ... }\n  execute() {\n    for (const c of this.children)\n      c.execute();\n  }\n}',
      participants: ['Component', 'Leaf', 'Composite', 'Client'],
      related: ['009', '016', '023']
    },
    {
      id: '009',
      name: 'Decora',
      pattern: 'Decorator',
      category: 'structural',
      types: ['ghost', 'fire'],
      stats: { complexity: 5, flexibility: 9, decoupling: 7, abstraction: 6, performance: 6, popularity: 8 },
      visual: { body: 'serpentine', features: ['aura', 'markings'], accent: 'wings' },
      intent: 'Attach additional responsibilities to an object dynamically. Provide a flexible alternative to subclassing for extending functionality.',
      problem: 'You want to add behavior to individual objects without affecting other objects of the same class, and inheritance is too inflexible.',
      solution: 'Wrap the object in a decorator that has the same interface. The decorator forwards requests to the wrapped object and can add behavior before or after.',
      analogy: 'Wearing clothes. A person is the core object. Each layer of clothing (shirt, jacket, raincoat) adds functionality without changing the person underneath.',
      codeHint: 'class CompressionDecorator\n  extends DataSourceDecorator {\n  writeData(data: string) {\n    const compressed = compress(data);\n    super.writeData(compressed);\n  }\n  readData(): string {\n    return decompress(\n      super.readData()\n    );\n  }\n}',
      participants: ['Component', 'ConcreteComponent', 'Decorator', 'ConcreteDecorator'],
      related: ['006', '008', '021']
    },
    {
      id: '010',
      name: 'Facadion',
      pattern: 'Facade',
      category: 'structural',
      types: ['normal', 'steel'],
      stats: { complexity: 2, flexibility: 4, decoupling: 8, abstraction: 6, performance: 8, popularity: 9 },
      visual: { body: 'wide', features: ['shield'], accent: 'markings' },
      intent: 'Provide a unified interface to a set of interfaces in a subsystem. Defines a higher-level interface that makes the subsystem easier to use.',
      problem: 'A subsystem has many classes and a complex API. Clients need to work with many objects and understand their relationships.',
      solution: 'Create a facade class that provides simple methods which delegate to the complex subsystem classes behind the scenes.',
      analogy: 'A hotel concierge. Instead of dealing with housekeeping, room service, the spa, and transportation separately, you tell the concierge what you need and they handle it all.',
      codeHint: 'class VideoConverter {\n  convert(filename, format) {\n    const file = new VideoFile(filename);\n    const codec = CodecFactory\n      .extract(file);\n    const result = BitrateReader\n      .convert(codec, format);\n    return new File(result);\n  }\n}',
      participants: ['Facade', 'Subsystem classes', 'Client'],
      related: ['006', '017', '005']
    },
    {
      id: '011',
      name: 'Flysprite',
      pattern: 'Flyweight',
      category: 'structural',
      types: ['bug', 'fairy'],
      stats: { complexity: 7, flexibility: 3, decoupling: 4, abstraction: 6, performance: 10, popularity: 4 },
      visual: { body: 'round', features: ['wings', 'antennae'], accent: 'markings' },
      intent: 'Use sharing to support large numbers of fine-grained objects efficiently.',
      problem: 'Your application needs a huge number of objects that would consume too much memory. Many objects share common data.',
      solution: 'Split object state into intrinsic (shared, immutable) and extrinsic (unique, contextual). Store intrinsic state in shared flyweight objects, pass extrinsic state from outside.',
      analogy: 'Font rendering. Every letter "A" in a document looks the same (intrinsic: glyph shape). Only position and size vary (extrinsic). You don\'t create a new glyph object for each "A".',
      codeHint: 'class TreeType { // flyweight\n  constructor(\n    public name: string,\n    public color: string,\n    public texture: string\n  ) {}\n  draw(canvas, x, y) { ... }\n}\n// Factory ensures sharing\nclass TreeFactory {\n  static types = new Map();\n  static getType(name, color, tex) {\n    const key = name+color+tex;\n    if (!this.types.has(key))\n      this.types.set(key,\n        new TreeType(name,color,tex));\n    return this.types.get(key);\n  }\n}',
      participants: ['Flyweight', 'ConcreteFlyweight', 'FlyweightFactory', 'Client'],
      related: ['008', '005']
    },
    {
      id: '012',
      name: 'Proxyon',
      pattern: 'Proxy',
      category: 'structural',
      types: ['ghost', 'normal'],
      stats: { complexity: 5, flexibility: 6, decoupling: 7, abstraction: 6, performance: 6, popularity: 7 },
      visual: { body: 'tall', features: ['aura', 'shield'], accent: 'markings' },
      intent: 'Provide a surrogate or placeholder for another object to control access to it.',
      problem: 'You need to control access to an object: lazy initialization, access control, logging, caching, etc. But you want to keep the same interface.',
      solution: 'Create a proxy class with the same interface as the real object. The proxy holds a reference to the real object and intercepts requests, adding its own logic.',
      analogy: 'A credit card is a proxy for your bank account. It has the same interface (pay for things) but adds authorization checks and doesn\'t require carrying cash.',
      codeHint: 'class CachingProxy {\n  constructor(\n    private service: ThirdPartyAPI\n  ) {}\n  private cache = new Map();\n\n  getData(key: string) {\n    if (!this.cache.has(key)) {\n      this.cache.set(key,\n        this.service.getData(key));\n    }\n    return this.cache.get(key);\n  }\n}',
      participants: ['Subject', 'RealSubject', 'Proxy', 'Client'],
      related: ['006', '009']
    },

    // ===== BEHAVIORAL (013-023) =====
    {
      id: '013',
      name: 'Chainark',
      pattern: 'Chain of Responsibility',
      category: 'behavioral',
      types: ['water', 'fighting'],
      stats: { complexity: 5, flexibility: 8, decoupling: 9, abstraction: 6, performance: 7, popularity: 7 },
      visual: { body: 'serpentine', features: ['claws', 'tail'], accent: 'markings' },
      intent: 'Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request.',
      problem: 'A request needs to be processed, but you don\'t know in advance which handler should process it. The handler should be determined at runtime.',
      solution: 'Chain handler objects together. Each handler decides to process the request or pass it to the next handler in the chain.',
      analogy: 'Calling tech support. Your call goes to level 1 support first. If they can\'t help, it\'s escalated to level 2, then level 3, until someone can handle your issue.',
      codeHint: 'abstract class Handler {\n  private next: Handler | null = null;\n  setNext(h: Handler) {\n    this.next = h;\n    return h;\n  }\n  handle(request) {\n    if (this.next)\n      return this.next.handle(request);\n    return null;\n  }\n}',
      participants: ['Handler', 'ConcreteHandler', 'Client'],
      related: ['008', '009', '014']
    },
    {
      id: '014',
      name: 'Commandex',
      pattern: 'Command',
      category: 'behavioral',
      types: ['fighting', 'electric'],
      stats: { complexity: 5, flexibility: 8, decoupling: 9, abstraction: 7, performance: 7, popularity: 8 },
      visual: { body: 'angular', features: ['claws', 'horns'], accent: 'aura' },
      intent: 'Encapsulate a request as an object, letting you parameterize clients with different requests, queue requests, and support undoable operations.',
      problem: 'You want to decouple the object that invokes an operation from the object that performs it. You also want to support undo, logging, or queuing.',
      solution: 'Turn each request into a stand-alone object containing all information about the request. Pass commands to invokers which execute them without knowing the specifics.',
      analogy: 'Ordering at a restaurant. You (client) write your order (command) on a slip. The waiter (invoker) takes it to the kitchen (receiver). The slip can be queued, logged, or cancelled.',
      codeHint: 'interface Command {\n  execute(): void;\n  undo(): void;\n}\n\nclass PasteCommand implements Command {\n  constructor(\n    private editor: Editor,\n    private backup: string\n  ) {}\n  execute() {\n    this.backup = editor.text;\n    editor.replaceSelection(\n      clipboard.get()\n    );\n  }\n  undo() { editor.text = this.backup; }\n}',
      participants: ['Command', 'ConcreteCommand', 'Invoker', 'Receiver', 'Client'],
      related: ['013', '018', '021']
    },
    {
      id: '015',
      name: 'Runevox',
      pattern: 'Interpreter',
      category: 'behavioral',
      types: ['psychic', 'fairy'],
      stats: { complexity: 8, flexibility: 5, decoupling: 4, abstraction: 9, performance: 3, popularity: 3 },
      visual: { body: 'tall', features: ['horns', 'aura', 'markings'], accent: 'wings' },
      intent: 'Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.',
      problem: 'You have a recurring problem that can be expressed as sentences in a simple language, and you want to interpret these sentences.',
      solution: 'Define a class for each grammar rule. Terminal expressions handle atomic elements, non-terminal expressions handle compositions. Build an abstract syntax tree and interpret it.',
      analogy: 'Musical notation. Each symbol (note, rest, time signature) is a grammar rule. A musician "interprets" the sheet music by reading symbols and producing sound according to the rules.',
      codeHint: 'interface Expression {\n  interpret(ctx: Context): number;\n}\n\nclass NumberExp implements Expression {\n  constructor(private val: number) {}\n  interpret() { return this.val; }\n}\n\nclass AddExp implements Expression {\n  constructor(\n    private left: Expression,\n    private right: Expression\n  ) {}\n  interpret(ctx) {\n    return this.left.interpret(ctx)\n      + this.right.interpret(ctx);\n  }\n}',
      participants: ['AbstractExpression', 'TerminalExpression', 'NonterminalExpression', 'Context', 'Client'],
      related: ['008', '016', '023']
    },
    {
      id: '016',
      name: 'Traversk',
      pattern: 'Iterator',
      category: 'behavioral',
      types: ['flying', 'water'],
      stats: { complexity: 4, flexibility: 7, decoupling: 8, abstraction: 6, performance: 7, popularity: 9 },
      visual: { body: 'serpentine', features: ['wings', 'tail'], accent: 'markings' },
      intent: 'Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.',
      problem: 'Collections can have complex internal structures (trees, graphs, stacks). Clients need to traverse them without knowing the internals.',
      solution: 'Extract the traversal logic into a separate Iterator object. The collection provides a method to create iterators compatible with its structure.',
      analogy: 'A TV remote\'s channel buttons. You press "next" to go through channels without knowing how channels are stored internally (satellite, cable, antenna).',
      codeHint: 'interface Iterator<T> {\n  hasNext(): boolean;\n  next(): T;\n}\n\nclass TreeIterator<T>\n  implements Iterator<T> {\n  private stack: Node<T>[] = [];\n  constructor(root: Node<T>) {\n    this.stack.push(root);\n  }\n  hasNext() {\n    return this.stack.length > 0;\n  }\n  next() { /* DFS logic */ }\n}',
      participants: ['Iterator', 'ConcreteIterator', 'Aggregate', 'ConcreteAggregate'],
      related: ['008', '018', '023']
    },
    {
      id: '017',
      name: 'Mediox',
      pattern: 'Mediator',
      category: 'behavioral',
      types: ['psychic', 'normal'],
      stats: { complexity: 6, flexibility: 6, decoupling: 10, abstraction: 7, performance: 6, popularity: 6 },
      visual: { body: 'wide', features: ['aura', 'antennae'], accent: 'markings' },
      intent: 'Define an object that encapsulates how a set of objects interact. Promotes loose coupling by keeping objects from referring to each other explicitly.',
      problem: 'A set of objects communicate in complex ways. The resulting interdependencies make the system hard to understand and modify.',
      solution: 'Introduce a mediator object. Instead of communicating directly, components notify the mediator, which decides how to route messages.',
      analogy: 'An air traffic control tower. Pilots don\'t communicate with each other directly. They all talk to the tower (mediator), which coordinates everyone safely.',
      codeHint: 'class ChatRoom {\n  private users = new Map();\n\n  register(user: User) {\n    this.users.set(user.name, user);\n    user.setChatRoom(this);\n  }\n\n  send(msg: string,\n    from: User, to: string) {\n    this.users.get(to)\n      ?.receive(msg, from.name);\n  }\n}',
      participants: ['Mediator', 'ConcreteMediator', 'Colleague', 'ConcreteColleague'],
      related: ['010', '019', '013']
    },
    {
      id: '018',
      name: 'Memorith',
      pattern: 'Memento',
      category: 'behavioral',
      types: ['ice', 'ghost'],
      stats: { complexity: 5, flexibility: 5, decoupling: 6, abstraction: 5, performance: 4, popularity: 5 },
      visual: { body: 'round', features: ['shield', 'aura'], accent: 'markings' },
      intent: 'Without violating encapsulation, capture and externalize an object\'s internal state so that the object can be restored to this state later.',
      problem: 'You need to save and restore an object\'s state (for undo, checkpoints, etc.) but the object\'s fields may be private.',
      solution: 'The object (Originator) creates a snapshot of its state in a Memento object. A Caretaker stores mementos without peeking inside. The originator can restore from a memento.',
      analogy: 'Saving your game. The game creates a save file (memento) capturing your current state. You can load it later to return exactly where you were, without the save file understanding the game\'s internals.',
      codeHint: 'class Editor {\n  private content: string;\n  createSnapshot(): Snapshot {\n    return new Snapshot(this,\n      this.content);\n  }\n  restore(s: Snapshot) {\n    this.content = s.getState();\n  }\n}\n\nclass Snapshot {\n  constructor(\n    private editor: Editor,\n    private state: string\n  ) {}\n  getState() { return this.state; }\n}',
      participants: ['Originator', 'Memento', 'Caretaker'],
      related: ['014', '016', '004']
    },
    {
      id: '019',
      name: 'Watchowl',
      pattern: 'Observer',
      category: 'behavioral',
      types: ['flying', 'psychic'],
      stats: { complexity: 4, flexibility: 8, decoupling: 9, abstraction: 6, performance: 6, popularity: 10 },
      visual: { body: 'round', features: ['wings', 'antennae'], accent: 'aura' },
      intent: 'Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.',
      problem: 'Multiple objects need to react to changes in another object, but you don\'t want tight coupling between them.',
      solution: 'The subject maintains a list of observers and notifies them of state changes. Observers register/unregister themselves and define an update method.',
      analogy: 'A newspaper subscription. You (observer) subscribe to a newspaper (subject). When a new edition is published, all subscribers automatically receive it. You can unsubscribe anytime.',
      codeHint: 'class EventEmitter {\n  private listeners = new Map();\n\n  on(event, callback) {\n    if (!this.listeners.has(event))\n      this.listeners.set(event, []);\n    this.listeners.get(event)\n      .push(callback);\n  }\n\n  emit(event, data) {\n    this.listeners.get(event)\n      ?.forEach(cb => cb(data));\n  }\n}',
      participants: ['Subject', 'ConcreteSubject', 'Observer', 'ConcreteObserver'],
      related: ['017', '020', '014']
    },
    {
      id: '020',
      name: 'Morpheon',
      pattern: 'State',
      category: 'behavioral',
      types: ['poison', 'fire'],
      stats: { complexity: 6, flexibility: 8, decoupling: 7, abstraction: 7, performance: 7, popularity: 7 },
      visual: { body: 'serpentine', features: ['horns', 'tail', 'aura'], accent: 'markings' },
      intent: 'Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.',
      problem: 'An object\'s behavior depends on its state, and it must change behavior at runtime. Complex conditionals (if/switch) based on state are hard to maintain.',
      solution: 'Create State classes for each possible state. The context delegates behavior to the current state object. State transitions happen by swapping the state object.',
      analogy: 'A phone behaves differently depending on its state: locked, home screen, in-call. The same button press does different things in each state. The phone "becomes" a different device.',
      codeHint: 'class AudioPlayer {\n  private state: State;\n  constructor() {\n    this.state = new ReadyState(this);\n  }\n  changeState(state: State) {\n    this.state = state;\n  }\n  clickPlay() {\n    this.state.clickPlay();\n  }\n}',
      participants: ['Context', 'State', 'ConcreteState'],
      related: ['021', '005']
    },
    {
      id: '021',
      name: 'Strateon',
      pattern: 'Strategy',
      category: 'behavioral',
      types: ['fighting', 'dark'],
      stats: { complexity: 3, flexibility: 9, decoupling: 8, abstraction: 6, performance: 7, popularity: 9 },
      visual: { body: 'angular', features: ['claws', 'horns'], accent: 'markings' },
      intent: 'Define a family of algorithms, encapsulate each one, and make them interchangeable. Lets the algorithm vary independently from clients that use it.',
      problem: 'You need different variants of an algorithm and want to switch between them at runtime without complex conditionals.',
      solution: 'Extract each algorithm into a separate class with a common interface. The context holds a reference to a strategy and delegates the work to it.',
      analogy: 'Getting to the airport. You can drive, take a bus, cycle, or call a cab. Each is a different strategy for the same goal. You pick based on budget, time, and conditions.',
      codeHint: 'interface SortStrategy {\n  sort(data: number[]): number[];\n}\n\nclass Sorter {\n  constructor(\n    private strategy: SortStrategy\n  ) {}\n  setStrategy(s: SortStrategy) {\n    this.strategy = s;\n  }\n  sort(data: number[]) {\n    return this.strategy.sort(data);\n  }\n}',
      participants: ['Strategy', 'ConcreteStrategy', 'Context'],
      related: ['020', '022', '007']
    },
    {
      id: '022',
      name: 'Templox',
      pattern: 'Template Method',
      category: 'behavioral',
      types: ['normal', 'grass'],
      stats: { complexity: 3, flexibility: 5, decoupling: 5, abstraction: 6, performance: 8, popularity: 8 },
      visual: { body: 'tall', features: ['shield', 'markings'], accent: 'tail' },
      intent: 'Define the skeleton of an algorithm in a method, deferring some steps to subclasses. Lets subclasses redefine certain steps without changing the algorithm\'s structure.',
      problem: 'Several classes have similar algorithms with only small differences in certain steps. Duplicating the whole algorithm in each class violates DRY.',
      solution: 'Put the algorithm skeleton in a base class template method. Make varying steps abstract or provide default implementations. Subclasses override only the steps they need.',
      analogy: 'A recipe template. "Make a beverage: boil water, brew, pour, add condiments." Coffee and tea follow the same template but implement "brew" and "condiments" differently.',
      codeHint: 'abstract class DataMiner {\n  mine(path: string) {  // template\n    const file = this.openFile(path);\n    const data = this.extractData(file);\n    const parsed = this.parseData(data);\n    this.analyze(parsed);\n    this.sendReport();\n  }\n  abstract openFile(path: string): File;\n  abstract extractData(f: File): Raw;\n  abstract parseData(r: Raw): Data;\n  // hooks with defaults:\n  analyze(d: Data) { /* basic */ }\n  sendReport() { /* email */ }\n}',
      participants: ['AbstractClass', 'ConcreteClass'],
      related: ['003', '021']
    },
    {
      id: '023',
      name: 'Visitrix',
      pattern: 'Visitor',
      category: 'behavioral',
      types: ['flying', 'bug'],
      stats: { complexity: 7, flexibility: 7, decoupling: 5, abstraction: 8, performance: 6, popularity: 4 },
      visual: { body: 'angular', features: ['wings', 'antennae', 'claws'], accent: 'markings' },
      intent: 'Represent an operation to be performed on elements of an object structure. Lets you define a new operation without changing the classes of the elements.',
      problem: 'You need to perform many unrelated operations on objects in a structure, but you don\'t want to pollute the classes with these operations.',
      solution: 'Create visitor classes for each operation. Elements accept a visitor and call the visitor\'s method for their type (double dispatch). New operations = new visitors.',
      analogy: 'A building inspector visiting different rooms. The inspector (visitor) has different procedures for kitchens, bathrooms, and bedrooms. New inspection types don\'t require remodeling rooms.',
      codeHint: 'interface Visitor {\n  visitCircle(c: Circle): void;\n  visitRect(r: Rect): void;\n}\n\nclass ExportVisitor\n  implements Visitor {\n  visitCircle(c: Circle) {\n    return `<circle r="${c.r}"/>`;\n  }\n  visitRect(r: Rect) {\n    return `<rect w="${r.w}"/>`;\n  }\n}\n\nclass Circle {\n  accept(v: Visitor) {\n    v.visitCircle(this);\n  }\n}',
      participants: ['Visitor', 'ConcreteVisitor', 'Element', 'ConcreteElement', 'ObjectStructure'],
      related: ['008', '016', '015']
    },
    {
      id: '024',
      name: 'Privor',
      pattern: 'Private Class Data',
      category: 'structural',
      types: ['dark', 'steel'],
      stats: { complexity: 2, flexibility: 3, decoupling: 5, abstraction: 4, performance: 9, popularity: 3 },
      visual: { body: 'round', features: ['shield', 'aura'], accent: 'markings' },
      intent: 'Control write access to class attributes by separating data from methods that use it, encapsulating class data initialization.',
      problem: 'A class exposes its attributes through setters, making it possible to change state after initialization when it shouldn\'t be changed.',
      solution: 'Move class data into a separate data class that provides only getters. The main class holds a reference to this immutable data object.',
      analogy: 'A sealed envelope. Once you put the letter inside and seal it, anyone can read the address (getter) but no one can change the contents without opening a new envelope.',
      codeHint: 'class CircleData {\n  constructor(\n    private _radius: number,\n    private _color: string,\n    private _origin: Point\n  ) {}\n  get radius() { return this._radius; }\n  get color() { return this._color; }\n  get origin() { return this._origin; }\n}\n\nclass Circle {\n  private data: CircleData;\n  constructor(r, c, o) {\n    this.data = new CircleData(r, c, o);\n  }\n}',
      participants: ['MainClass', 'DataClass'],
      related: ['005', '018']
    },

    // ===== ARCHITECTURAL (025+) =====
    {
      id: '025',
      name: 'Stranglor',
      pattern: 'Strangler Fig',
      category: 'architectural',
      types: ['grass', 'ghost'],
      stats: { complexity: 7, flexibility: 9, decoupling: 9, abstraction: 7, performance: 6, popularity: 8 },
      visual: { body: 'serpentine', features: ['aura', 'tail'], accent: 'markings' },
      intent: 'Incrementally migrate a legacy system by gradually replacing specific pieces of functionality with new applications and services until the old system is completely replaced.',
      problem: 'You have a large monolithic legacy system that needs to be modernized, but a full rewrite is too risky and expensive. The system must keep running during migration.',
      solution: 'Create a facade (the "fig") that intercepts calls to the legacy system. Gradually implement new functionality behind the facade. Route requests to new code when ready, falling back to the old system. Over time the new system grows around the old one until the legacy code can be removed entirely.',
      analogy: 'A strangler fig tree in the rainforest. It starts as a small vine growing on a host tree, gradually wrapping around it and growing its own roots. Eventually the fig completely envelops the host, which dies and decomposes, leaving the fig standing in its place.',
      codeHint: 'class OrderService {\n  constructor(\n    private legacy: LegacyOrderSystem,\n    private modern: ModernOrderAPI,\n    private flags: FeatureFlags\n  ) {}\n\n  getOrder(id: string): Order {\n    if (this.flags.isEnabled(\n      \'modern-orders\')) {\n      return this.modern.getOrder(id);\n    }\n    return this.legacy.getOrder(id);\n  }\n\n  // Migrate endpoint by endpoint...\n}',
      participants: ['Facade/Proxy', 'Legacy System', 'New System', 'Router/Feature Flags'],
      related: ['010', '012', '006']
    },
    {
      id: '026',
      name: 'Splitclaw',
      pattern: 'CQRS',
      category: 'architectural',
      types: ['psychic', 'fighting'],
      stats: { complexity: 8, flexibility: 9, decoupling: 10, abstraction: 8, performance: 8, popularity: 8 },
      visual: { body: 'multi', features: ['horns', 'claws'], accent: 'aura' },
      intent: 'Separate read and write operations into different models, allowing each to be optimized, scaled, and evolved independently.',
      problem: 'A single data model serves both reads and writes, but their requirements differ dramatically. Reads need denormalized views for speed; writes need normalized models for consistency. Optimizing for one hurts the other.',
      solution: 'Split the application into a Command side (writes/mutations) and a Query side (reads/projections). Commands update the write model and publish events. The read model is built from these events, optimized for query patterns.',
      analogy: 'A restaurant kitchen. Orders go in one window (command), food comes out another (query). The kitchen (write model) is organized for cooking efficiency, while the serving counter (read model) is organized for quick pickup. Different optimizations, same data.',
      codeHint: '// Command side\nclass CreateOrderCommand {\n  constructor(\n    public items: Item[],\n    public userId: string\n  ) {}\n}\n\nclass CommandHandler {\n  handle(cmd: CreateOrderCommand) {\n    const order = Order.create(cmd);\n    this.repo.save(order);\n    this.bus.publish(\n      new OrderCreatedEvent(order));\n  }\n}\n\n// Query side\nclass OrderQueryService {\n  getOrderSummary(id: string) {\n    return this.readDb\n      .query(\'SELECT * FROM\n        order_views WHERE id=?\',\n        [id]);\n  }\n}',
      participants: ['Command', 'Command Handler', 'Write Model', 'Event Bus', 'Query Model', 'Query Handler', 'Projection'],
      related: ['027', '014', '019']
    },
    {
      id: '027',
      name: 'Chronolith',
      pattern: 'Event Sourcing',
      category: 'architectural',
      types: ['ice', 'water'],
      stats: { complexity: 9, flexibility: 8, decoupling: 8, abstraction: 8, performance: 5, popularity: 7 },
      visual: { body: 'tall', features: ['shield', 'aura', 'markings'], accent: 'horns' },
      intent: 'Store state changes as a sequence of immutable events rather than overwriting current state. Rebuild current state by replaying events from the beginning.',
      problem: 'Traditional CRUD overwrites data, losing the history of how you got to the current state. You can\'t answer "what happened?" or rebuild past states. Audit trails are bolted on and unreliable.',
      solution: 'Persist every state change as an immutable event in an append-only store. The current state is derived by replaying all events. Snapshots can optimize replay performance. Events become the single source of truth.',
      analogy: 'A bank ledger. Instead of just showing your current balance ($500), it records every transaction: +$1000 deposit, -$200 rent, -$300 groceries. You can always reconstruct any past balance and have a complete audit trail.',
      codeHint: 'class EventStore {\n  private events: Event[] = [];\n\n  append(event: Event) {\n    event.timestamp = Date.now();\n    event.version = this.events.length;\n    this.events.push(\n      Object.freeze(event));\n  }\n\n  getEvents(aggregateId: string) {\n    return this.events.filter(\n      e => e.aggregateId === id);\n  }\n}\n\n// Rebuild state\nfunction rebuild(events: Event[]) {\n  return events.reduce(\n    (state, event) =>\n      applyEvent(state, event),\n    initialState);\n}',
      participants: ['Event Store', 'Event', 'Aggregate', 'Snapshot', 'Projection', 'Event Handler'],
      related: ['026', '018', '016']
    },
    {
      id: '028',
      name: 'Breakerus',
      pattern: 'Circuit Breaker',
      category: 'architectural',
      types: ['electric', 'steel'],
      stats: { complexity: 5, flexibility: 6, decoupling: 7, abstraction: 5, performance: 8, popularity: 9 },
      visual: { body: 'angular', features: ['shield', 'aura'], accent: 'horns' },
      intent: 'Prevent cascading failures in distributed systems by detecting failures and temporarily stopping requests to a failing service, giving it time to recover.',
      problem: 'In a distributed system, one failing service can cause callers to hang waiting for timeouts, exhausting resources and cascading the failure across the entire system.',
      solution: 'Wrap calls to external services in a circuit breaker. Track failures: when they exceed a threshold, "open" the circuit and fail fast without calling the service. After a timeout, allow a test request through ("half-open"). If it succeeds, close the circuit; if not, stay open.',
      analogy: 'An electrical circuit breaker in your home. When it detects a dangerous current overload, it trips and cuts the circuit to prevent a fire. You can reset it once the problem is fixed, and electricity flows again.',
      codeHint: 'class CircuitBreaker {\n  private failures = 0;\n  private state = \'CLOSED\';\n  private nextRetry = 0;\n\n  async call(fn: () => Promise<T>) {\n    if (this.state === \'OPEN\') {\n      if (Date.now() < this.nextRetry)\n        throw new CircuitOpenError();\n      this.state = \'HALF_OPEN\';\n    }\n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (e) {\n      this.onFailure();\n      throw e;\n    }\n  }\n\n  private onFailure() {\n    this.failures++;\n    if (this.failures >= this.threshold)\n      this.trip();\n  }\n\n  private trip() {\n    this.state = \'OPEN\';\n    this.nextRetry =\n      Date.now() + this.timeout;\n  }\n}',
      participants: ['Circuit Breaker', 'Service', 'Client', 'Fallback', 'Monitor'],
      related: ['012', '020', '025']
    }
  ]
};
